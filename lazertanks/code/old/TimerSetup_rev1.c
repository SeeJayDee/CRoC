uint8_t pulseCount = 0;
#define TRANSMIT_PIN 2

/* Timer assignments:
 * Timer 0 - CTC mode - IR transmitter 						--- expect 37.7 kHz
 * Timer 1 - PWM mode (8-bit) - RGB leds 					--- expect 7.81 kHz
 * Timer 3 - Interrupt mode, interrupts control servo pins 	--- expect   50  Hz
 * Timer 4 - PWM mode (OC4A & OC4D) 						--- expect 23.4 kHz
 */
 
/* PIN ASSIGNMENTS - Arduino Pin Number - (access register) [range]
 * Motor 1: D13 (OCR4A) [0-1023]
 * Motor 2: D6  (OCR4D) [0-1023]
 * Servo 1: D5 (OCR3A) [0-39999]; half-microSeconds
 * Servo 2: D4 (OCR3B) [0-39999]; half-microSeconds; ***software (interrupt) -based
 * RGB Red: D9  (OCR1A) [0-255]
 * RGB Grn: D10 (OCR1B) [0-255]
 * RGB Blu: D11 (OCR1C) [0-255]
 * 38 kHz : D3
 *
 * If possible we should use something like:
 * #define MOTOR1_SPEED OCR4A
 */
 
 void initializeTimers()
 {
	/* Rev 1 - code adjusted for unscaled system clock (16MHz) */
	 
	/* enable global interrupts */
	sei();
	 
	 
	 
	/* Initialize Timer 0 for 38kHz IR signal generator */	 
	OCR0A = 52; /* this cycles the timer at 37.7kHz*/
	OCR0B = 13; /* this clears Dig. pin 3 (PD0) 1/4-way through the cycle (Phillips RC-5 compliant) */
	
	TCCR0A = 0x00; /* clear all bits */		
	TCCR0B = 0x00; /* clear all bits */
	
	TCCR0A |= (1<<COM0B1) + (1<<WGM01) + (1<<WGM00); /* clear PD0 on compare match; fPWM, OCR0A as TOP */	 
		DDRD |= _BV(0); /* Set dig. pin 3 (PD0) to output mode. */

	TCCR0B  |= (1<<WGM02) + (1<<CS01); /* fastPWM-OCR0A.top; set prescaler to 8 */

	TIMSK0 &= ~(1<<TOIE0);
	/*TIMSK0 |= (1<<OCIE0B); /* Enables interrupt on falling pulse edge, once per cycle. Place this in IR-transmit function. */
	
	/* Note w.r.t. TIMER0 ---  Arduino uses TIMER0 for millis() and micros(). See 'wiring.c' for further details.
	 * 
	 */
	 
	/* End Timer 0 */ 
	 
	 
	/* Initialize Timer 1 for 8-bit PWM */
	OCR1A = 0x0080; /* initialize all OCRs to 50% duty cycle (0x0080) */
	OCR1B = 0x0080;
	OCR1C = 0x0080;
	 
	TCCR1A = 0x00; /* clear all bits */		
	TCCR1B = 0x00; /* clear all bits */
	
	TCCR1A |= (1<<COM1A1) + (1<<COM1B1) + (1<<COM1C1) + (1<<WGM10); /* clear on compare match; 8-bitFPWM */
		DDRB |= _BV(5) + _BV(6) + _BV(7); /* set dig. pins 9,10,11 (PD5,PD6,PD7) to output mode */

	TCCR1B |= (1<<WGM12) + (1<<CS11); /* 8-bitFastPWM; prescaler = 8 (expected freq = 7.8kHz) */
		
	TIMSK1 |= (1<<TOIE1); /* run an ISR whenever Timer1 overflows - for correct millis() functionality */
	/* End Timer 1 */ 
	 
	 
	/* Initialize Timer 3 for a 20ms period, with direct servo control output on OC3A and indirect servo
	 * control via interrupt generated by OCR3B compare match */
	OCR3A = 0x00; /* IMPORTANT - initialize OCRs to 0 to prevent weirdness */
	OCR3B = 0x00;
	ICR3 = 39999; /* this sets the counter period to 20ms */
	 
	TCCR3A = 0x00; /* clear all bits */		
	TCCR3B = 0x00; /* clear all bits */		
	TCCR3C = 0x00; /* clear all bits */		
	TIMSK3 = 0x00; /* clear all bits */
	 
	TCCR3A |= (1<<COM3A1) + (1<<WGM31); /* clears OC3A (dig. pin 5) on compare match */
		DDRC |= _BV(6); /* Set dig. pin 5 (PC6) to output mode */

	TCCR3B |= (1<<WGM33) + (1<<WGM32) + (1<<CS31); /* FPWM mode with period defined by ICR3; prescaler = 8 */

	TIMSK3 |= (1<<ICIE3) + (1<<OCIE3B); /* enable interrupts for count==ICR3 and count==OCR3B */
		DDRD |= _BV(4); /* Set dig. pin 4 (PD4) to output mode*/
	/* End Timer 3 */
	 
	 
	/* Initialize Hi-speed Timer 4 for 10-bit PWM on OC4A (Dig. pin 13) & OC4D (Dig. pin 6) */
	OCR4C = write_10bit_register(1023); /* OCR4C defines the "TOP" value for Timer/Counter 4 */
	OCR4A = write_10bit_register(512);
	OCR4D = write_10bit_register(512);

	TCCR4A = 0x00; /* clear all bits */
	TCCR4B = 0x00; /* clear all bits */
	TCCR4C = 0x00; /* clear all bits */
	TCCR4D = 0x00; /* clear all bits */
	TCCR4E = 0x00; /* clear all bits */
	TIMSK4 = 0x00; /* clear all bits */

	TCCR4A |= (1<<COM4A1) + (1<<PWM4A); /* clear OC4A (Dig. pin 13) on compare match; enable OC4A PWM */
		DDRC |= _BV(7); /* Set dig. pin 13 (PC7) to output mode*/     

	TCCR4B |= (1<<CS40); /* prescaler = 1 */
   
	TCCR4C |= (1<<COM4D1) + (1<<PWM4D); /* clear OC4D (Dig. pin 6) on compare match; enable OC4D PWM */
		DDRD |= _BV(7); /* Set dig. pin 6 (PD7) to output mode*/

	 
	/* PLL control --- This may or may not affect USB functionality... */
	/* Connecting or disconnecting USB might screw up Timer4 operation until the next reset.
 	 * If USB is connected and enabled, the PLL will need no further configuration. Otherwise it will need
	 * to be set up as follows: */
	if ((USBCON & (1<<USBE)) == 0)
	{
		/* if USB is disabled (i.e. USBE bit in USBCON is 0), enable the PLL */
		PLLFRQ = 0x00;  /* clear all bits */
			PLLFRQ |= (1<<PLLTM1) + (1<<PDIV2);
			/* divides frequency sent to Timer4 by 1.5; Sets raw frequency to 48MHz */
		 
		/* CODE COPIED FROM "USBCore.cpp" */
		PLLCSR |= (1<<PINDIV); /* divide 16MHz cpu clock by 2 for input into PLL */
		PLLCSR |= (1<<PLLE); /* enable PhaseLockedLoop */
		while (!(PLLCSR & (1<<PLOCK)))		// wait for lock pll
		{
		}

		/* Some tests on specific versions of macosx (10.7.3), reported some
		// strange behaviors when the board is reset using the serial
		// port touch at 1200 bps. This delay fixes this behavior. */
		delay(1);
		/* END COPIED CODE */		 
	}
	/* End Timer 4 */

 /* End Timer Initializations */	 
 }
 
ISR(TIMER3_CAPT_vect)
 {
	/* FOR SERVO
	 * This interrupt is triggered when Timer3 reaches the value in ICR3 (39,999 in this case).
	 * We set the output pin (Dig. pin 4) high at the end (aka beginning) of each timer cycle. */
	PORTD |= _BV(4); /* Set Dig. pin 4 (PD4) HIGH */
 }
 
ISR(TIMER3_COMPB_vect)
 {
	/* FOR SERVO
	 * This interrupt is triggered when Timer3 reaches the value in OCR3B.
	 * This time we clear the output pin (Dig. pin 4) at the end of each pulse. */
	PORTD &= ~(_BV(4)); /* Set Dig. pin 4 (PD4) LOW */
 }
 
ISR(TIMER0_COMPB_vect)
 {
	/* This interrupt is triggered on the falling edge of the 38kHz output pulse.
	 * We bitwise-AND pulseCount with 31 and increment it. Purpose: RC-5 IR transmits 1 bit
	 * per 32 pulses. */
	pulseCount = (++pulseCount)&0x1f; 
 } 
 
void transmitByte(uint8_t output)
{
	
}
 
 ISR(TIMER1_OVF_vect)
 {
	/* This contains modified code from 'wiring.c', making the necessary adjustments so that
	 * millis() and delay() still work despite changes made to TIMER0.
	 * The ISR associated with TIFR0.TOV0 will no longer run. This replaces it. */ 
	
	// the prescaler was set so that timer0 ticked every 64 clock cycles.
	// Now, timer1 ticks every 8 clock cycles. The overflow handler is called every 256 ticks.
	// microseconds per overflow was 1024, now 128
	#define CUSTOM_MICROSECONDS_PER_TIMER1_OVERFLOW (clockCyclesToMicroseconds(8 * 256))

	// the whole number of milliseconds per timer0 [now timer1] overflow. was 1 now 0. code removed.
	#define CUSTOM_MILLIS_INC (CUSTOM_MICROSECONDS_PER_TIMER1_OVERFLOW / 1000)

	// the fractional number of milliseconds per timer0 [now timer1] overflow. we shift right
	// by three to fit these numbers into a byte. (for the clock speeds we care
	// about - 8 and 16 MHz - this doesn't lose precision.) was 3 now 16
	#define CUSTOM_FRACT_INC ((CUSTOM_MICROSECONDS_PER_TIMER1_OVERFLOW % 1000) >> 3)
	#define CUSTOM_FRACT_MAX (1000 >> 3) // 125
		
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;
	static unsigned char OVF_count = 0; // overflow counter

	// m += CUSTOM_MILLIS_INC; // removed because CUSTOM_MILLIS_INC == 0
	f += CUSTOM_FRACT_INC;
	if (f >= CUSTOM_FRACT_MAX) {
		f -= CUSTOM_FRACT_MAX;
		++m;
	}

	timer0_fract = f;
	timer0_millis = m;
	
	++OVF_count; 								// increment this every time
	OVF_count &= 7; 							// constrain to max. of 7
	if (!OVF_count) {
		++timer0_overflow_count;	// timer0_overflow_count is only incremented if OVF_count == 0 (has counted past 7)
	}
 }
 
uint8_t write_10bit_register(uint16_t i)
 {
	TC4H = (i >> 8);
	return (uint8_t)(i & 0xff);
 }
 